"use strict";
(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [1843],
  {
    1843: (e, t, n) => {
      n.d(t, { default: () => w });
      var r,
        o = n(7620),
        i = [
          "br",
          "col",
          "colgroup",
          "dl",
          "hr",
          "iframe",
          "img",
          "input",
          "link",
          "menuitem",
          "meta",
          "ol",
          "param",
          "select",
          "table",
          "tbody",
          "tfoot",
          "thead",
          "tr",
          "ul",
          "wbr",
        ],
        a = {
          "accept-charset": "acceptCharset",
          acceptcharset: "acceptCharset",
          accesskey: "accessKey",
          allowfullscreen: "allowFullScreen",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          charset: "charSet",
          class: "className",
          classid: "classID",
          classname: "className",
          colspan: "colSpan",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controlslist: "controlsList",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          datetime: "dateTime",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          enctype: "encType",
          for: "htmlFor",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          maxlength: "maxLength",
          mediagroup: "mediaGroup",
          minlength: "minLength",
          nomodule: "noModule",
          novalidate: "noValidate",
          playsinline: "playsInline",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rowspan: "rowSpan",
          spellcheck: "spellCheck",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          tabindex: "tabIndex",
          typemustmatch: "typeMustMatch",
          usemap: "useMap",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          diffuseconstant: "diffuseConstant",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          edgemode: "edgeMode",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          externalresourcesrequired: "externalResourcesRequired",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          numoctaves: "numOctaves",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          ychannelselector: "yChannelSelector",
          zoomandpan: "zoomAndPan",
          onblur: "onBlur",
          onchange: "onChange",
          onclick: "onClick",
          oncontextmenu: "onContextMenu",
          ondoubleclick: "onDoubleClick",
          ondrag: "onDrag",
          ondragend: "onDragEnd",
          ondragenter: "onDragEnter",
          ondragexit: "onDragExit",
          ondragleave: "onDragLeave",
          ondragover: "onDragOver",
          ondragstart: "onDragStart",
          ondrop: "onDrop",
          onerror: "onError",
          onfocus: "onFocus",
          oninput: "onInput",
          oninvalid: "onInvalid",
          onkeydown: "onKeyDown",
          onkeypress: "onKeyPress",
          onkeyup: "onKeyUp",
          onload: "onLoad",
          onmousedown: "onMouseDown",
          onmouseenter: "onMouseEnter",
          onmouseleave: "onMouseLeave",
          onmousemove: "onMouseMove",
          onmouseout: "onMouseOut",
          onmouseover: "onMouseOver",
          onmouseup: "onMouseUp",
          onscroll: "onScroll",
          onsubmit: "onSubmit",
          ontouchcancel: "onTouchCancel",
          ontouchend: "onTouchEnd",
          ontouchmove: "onTouchMove",
          ontouchstart: "onTouchStart",
          onwheel: "onWheel",
        };
      function s(e, t, n) {
        let r = [...e]
          .map((e, r) => l(e, { ...n, index: r, level: t + 1 }))
          .filter(Boolean);
        return r.length ? r : null;
      }
      function l(e, t = {}) {
        if (!e || !(e instanceof Node)) return null;
        let { actions: n = [], index: r = 0, level: c = 0, randomKey: u } = t,
          d = e,
          h = `${c}-${r}`,
          p = [];
        return (u &&
          0 === c &&
          (h = `${(function (e = 6) {
            let t =
                "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
              n = "";
            for (let r = e; r > 0; --r)
              n += t[Math.round(Math.random() * (t.length - 1))];
            return n;
          })()}-${h}`),
        Array.isArray(n) &&
          n.forEach((t) => {
            t.condition(d, h, c) &&
              ("function" == typeof t.pre &&
                ((d = t.pre(d, h, c)) instanceof Node || (d = e)),
              "function" == typeof t.post && p.push(t.post(d, h, c)));
          }),
        p.length)
          ? p
          : (function (e, t) {
              let { key: n, level: r, ...l } = t;
              switch (e.nodeType) {
                case 1:
                  var c;
                  return o.createElement(
                    ((c = e.nodeName),
                    /[a-z]+[A-Z]+[a-z]+/.test(c) ? c : c.toLowerCase()),
                    (function (e, t) {
                      let n = { key: t };
                      if (e instanceof Element) {
                        let t = e.getAttribute("class");
                        t && (n.className = t),
                          [...e.attributes].forEach((e) => {
                            switch (e.name) {
                              case "class":
                                break;
                              case "style":
                                var t;
                                n[e.name] =
                                  "string" != typeof (t = e.value)
                                    ? {}
                                    : t.split(/ ?; ?/).reduce((e, t) => {
                                        let [n, r] = t
                                          .split(/ ?: ?/)
                                          .map((e, t) =>
                                            0 === t
                                              ? e.replace(/\s+/g, "")
                                              : e.trim()
                                          );
                                        if (n && r) {
                                          let t = n.replace(
                                              /(\w)-(\w)/g,
                                              (e, t, n) =>
                                                `${t}${n.toUpperCase()}`
                                            ),
                                            o = r.trim();
                                          Number.isNaN(Number(r)) ||
                                            (o = Number(r)),
                                            (e[n.startsWith("-") ? n : t] = o);
                                        }
                                        return e;
                                      }, {});
                                break;
                              case "allowfullscreen":
                              case "allowpaymentrequest":
                              case "async":
                              case "autofocus":
                              case "autoplay":
                              case "checked":
                              case "controls":
                              case "default":
                              case "defer":
                              case "disabled":
                              case "formnovalidate":
                              case "hidden":
                              case "ismap":
                              case "itemscope":
                              case "loop":
                              case "multiple":
                              case "muted":
                              case "nomodule":
                              case "novalidate":
                              case "open":
                              case "readonly":
                              case "required":
                              case "reversed":
                              case "selected":
                              case "typemustmatch":
                                n[a[e.name] || e.name] = !0;
                                break;
                              default:
                                n[a[e.name] || e.name] = e.value;
                            }
                          });
                      }
                      return n;
                    })(e, n),
                    s(e.childNodes, r, l)
                  );
                case 3: {
                  let t = e.nodeValue?.toString() ?? "";
                  if (
                    !l.allowWhiteSpaces &&
                    /^\s+$/.test(t) &&
                    !/[\u00A0\u202F]/.test(t)
                  )
                    return null;
                  if (!e.parentNode) return t;
                  let n = e.parentNode.nodeName.toLowerCase();
                  if (i.includes(n))
                    return (
                      /\S/.test(t) &&
                        console.warn(
                          `A textNode is not allowed inside '${n}'. Your text "${t}" will be ignored`
                        ),
                      null
                    );
                  return t;
                }
                case 8:
                default:
                  return null;
                case 11:
                  return s(e.childNodes, r, t);
              }
            })(d, { key: h, level: c, ...t });
      }
      function c(e, t = {}) {
        return "string" == typeof e
          ? (function (e, t = {}) {
              if (!e || "string" != typeof e) return null;
              let {
                includeAllNodes: n = !1,
                nodeOnly: r = !1,
                selector: o = "body > *",
                type: i = "text/html",
              } = t;
              try {
                let a = new DOMParser().parseFromString(e, i);
                if (n) {
                  let { childNodes: e } = a.body;
                  if (r) return e;
                  return [...e].map((e) => l(e, t));
                }
                let s = a.querySelector(o) || a.body.childNodes[0];
                if (!(s instanceof Node))
                  throw TypeError("Error parsing input");
                if (r) return s;
                return l(s, t);
              } catch (e) {}
              return null;
            })(e, t)
          : e instanceof Node
          ? l(e, t)
          : null;
      }
      var u = n(54568),
        d = Object.defineProperty,
        h = (e, t, n) => (
          ((e, t, n) =>
            t in e
              ? d(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n))(e, "symbol" != typeof t ? t + "" : t, n),
          n
        ),
        p = "react-inlinesvg",
        f = {
          IDLE: "idle",
          LOADING: "loading",
          LOADED: "loaded",
          FAILED: "failed",
          READY: "ready",
          UNSUPPORTED: "unsupported",
        };
      function g() {
        return !!(
          "undefined" != typeof window &&
          window.document &&
          window.document.createElement
        );
      }
      async function m(e, t) {
        let n = await fetch(e, t),
          r = n.headers.get("content-type"),
          [o] = (null != r ? r : "").split(/ ?; ?/);
        if (n.status > 299) throw Error("Not found");
        if (!["image/svg+xml", "text/plain"].some((e) => o.includes(e)))
          throw Error("Content type isn't valid: ".concat(o));
        return n.text();
      }
      var y = class {
        onReady(e) {
          this.isReady ? e() : this.subscribers.push(e);
        }
        async get(e, t) {
          var n, r;
          return (
            await (this.cacheApi
              ? this.fetchAndAddToPersistentCache(e, t)
              : this.fetchAndAddToInternalCache(e, t)),
            null !=
            (r = null == (n = this.cacheStore.get(e)) ? void 0 : n.content)
              ? r
              : ""
          );
        }
        set(e, t) {
          this.cacheStore.set(e, t);
        }
        isCached(e) {
          var t;
          return (
            (null == (t = this.cacheStore.get(e)) ? void 0 : t.status) ===
            f.LOADED
          );
        }
        async fetchAndAddToInternalCache(e, t) {
          let n = this.cacheStore.get(e);
          if ((null == n ? void 0 : n.status) === f.LOADING)
            return void (await this.handleLoading(e, async () => {
              this.cacheStore.set(e, { content: "", status: f.IDLE }),
                await this.fetchAndAddToInternalCache(e, t);
            }));
          if (!(null == n ? void 0 : n.content)) {
            this.cacheStore.set(e, { content: "", status: f.LOADING });
            try {
              let n = await m(e, t);
              this.cacheStore.set(e, { content: n, status: f.LOADED });
            } catch (t) {
              throw (
                (this.cacheStore.set(e, { content: "", status: f.FAILED }), t)
              );
            }
          }
        }
        async fetchAndAddToPersistentCache(e, t) {
          var n, r, o, i;
          let a = this.cacheStore.get(e);
          if ((null == a ? void 0 : a.status) === f.LOADED) return;
          if ((null == a ? void 0 : a.status) === f.LOADING)
            return void (await this.handleLoading(e, async () => {
              this.cacheStore.set(e, { content: "", status: f.IDLE }),
                await this.fetchAndAddToPersistentCache(e, t);
            }));
          this.cacheStore.set(e, { content: "", status: f.LOADING });
          let s = await (null == (n = this.cacheApi) ? void 0 : n.match(e));
          if (s) {
            let t = await s.text();
            this.cacheStore.set(e, { content: t, status: f.LOADED });
            return;
          }
          try {
            await (null == (r = this.cacheApi)
              ? void 0
              : r.add(new Request(e, t)));
            let n = await (null == (o = this.cacheApi) ? void 0 : o.match(e)),
              a = null != (i = await (null == n ? void 0 : n.text())) ? i : "";
            this.cacheStore.set(e, { content: a, status: f.LOADED });
          } catch (t) {
            throw (
              (this.cacheStore.set(e, { content: "", status: f.FAILED }), t)
            );
          }
        }
        async handleLoading(e, t) {
          var n;
          let r = 0;
          for (
            ;
            (null == (n = this.cacheStore.get(e)) ? void 0 : n.status) ===
              f.LOADING && r < 10;

          )
            await (function () {
              let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 1;
              return new Promise((t) => {
                setTimeout(t, 1e3 * e);
              });
            })(0.1),
              (r += 1);
          r >= 10 && (await t());
        }
        keys() {
          return [...this.cacheStore.keys()];
        }
        data() {
          return [...this.cacheStore.entries()].map((e) => {
            let [t, n] = e;
            return { [t]: n };
          });
        }
        async delete(e) {
          this.cacheApi && (await this.cacheApi.delete(e)),
            this.cacheStore.delete(e);
        }
        async clear() {
          if (this.cacheApi)
            for (let e of await this.cacheApi.keys())
              await this.cacheApi.delete(e);
          this.cacheStore.clear();
        }
        constructor() {
          h(this, "cacheApi"),
            h(this, "cacheStore"),
            h(this, "subscribers", []),
            h(this, "isReady", !1),
            (this.cacheStore = new Map());
          let e = p,
            t = !1;
          if (g()) {
            var n;
            (e = null != (n = window.REACT_INLINESVG_CACHE_NAME) ? n : p),
              (t =
                !!window.REACT_INLINESVG_PERSISTENT_CACHE &&
                "caches" in window);
          }
          t
            ? caches
                .open(e)
                .then((e) => {
                  (this.cacheApi = e),
                    (this.isReady = !0),
                    this.subscribers.forEach((e) => e());
                })
                .catch((e) => {
                  (this.isReady = !0),
                    console.error("Failed to open cache: ".concat(e.message));
                })
            : (this.isReady = !0);
        }
      };
      function v(e) {
        let t = (0, o.useRef)();
        return (
          (0, o.useEffect)(() => {
            t.current = e;
          }),
          t.current
        );
      }
      function k(e) {
        let {
            cacheRequests: t = !0,
            children: n = null,
            description: i,
            fetchOptions: a,
            innerRef: s,
            loader: l = null,
            onError: u,
            onLoad: d,
            src: h,
            title: p,
            uniqueHash: y,
          } = e,
          [k, w] = (0, o.useReducer)((e, t) => ({ ...e, ...t }), {
            content: "",
            element: null,
            isCached: t && r.isCached(e.src),
            status: f.IDLE,
          }),
          { content: x, element: b, isCached: E, status: A } = k,
          S = v(e),
          D = v(k),
          C = (0, o.useRef)(
            null != y
              ? y
              : (function (e) {
                  let t = "abcdefghijklmnopqrstuvwxyz",
                    n = ""
                      .concat(t)
                      .concat(t.toUpperCase())
                      .concat("1234567890"),
                    r = "";
                  for (let e = 0; e < 8; e++)
                    r += n[Math.floor(Math.random() * n.length)];
                  return r;
                })(0)
          ),
          L = (0, o.useRef)(!1),
          O = (0, o.useRef)(!1),
          R = (0, o.useCallback)(
            (e) => {
              L.current &&
                (w({
                  status:
                    "Browser does not support SVG" === e.message
                      ? f.UNSUPPORTED
                      : f.FAILED,
                }),
                null == u || u(e));
            },
            [u]
          ),
          N = (0, o.useCallback)(function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            L.current && w({ content: e, isCached: t, status: f.LOADED });
          }, []),
          T = (0, o.useCallback)(async () => {
            N(await m(h, a));
          }, [a, N, h]),
          I = (0, o.useCallback)(() => {
            try {
              let t = (function (e) {
                  let {
                    baseURL: t,
                    content: n,
                    description: r,
                    handleError: o,
                    hash: i,
                    preProcessor: a,
                    title: s,
                    uniquifyIDs: l = !1,
                  } = e;
                  try {
                    var u, d;
                    let e = ((u = n), (d = a) ? d(u) : u),
                      o = c(e, { nodeOnly: !0 });
                    if (!o || !(o instanceof SVGSVGElement))
                      throw Error("Could not convert the src to a DOM Node");
                    let h = (function e(t, n) {
                      let { baseURL: r = "", hash: o, uniquifyIDs: i } = n,
                        a = [
                          "id",
                          "href",
                          "xlink:href",
                          "xlink:role",
                          "xlink:arcrole",
                        ],
                        s = ["href", "xlink:href"];
                      return (
                        i &&
                          [...t.children].forEach((t) => {
                            var i;
                            if (
                              null == (i = t.attributes) ? void 0 : i.length
                            ) {
                              let e = Object.values(t.attributes).map((e) => {
                                let t = /url\((.*?)\)/.exec(e.value);
                                return (
                                  (null == t ? void 0 : t[1]) &&
                                    (e.value = e.value.replace(
                                      t[0],
                                      "url("
                                        .concat(r)
                                        .concat(t[1], "__")
                                        .concat(o, ")")
                                    )),
                                  e
                                );
                              });
                              a.forEach((t) => {
                                let n,
                                  r = e.find((e) => e.name === t);
                                r &&
                                  ((n = r.value),
                                  !s.includes(t) || !n || n.includes("#")) &&
                                  (r.value = ""
                                    .concat(r.value, "__")
                                    .concat(o));
                              });
                            }
                            return t.children.length ? e(t, n) : t;
                          }),
                        t
                      );
                    })(o, { baseURL: t, hash: i, uniquifyIDs: l });
                    if (r) {
                      let e = h.querySelector("desc");
                      (null == e ? void 0 : e.parentNode) &&
                        e.parentNode.removeChild(e);
                      let t = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "desc"
                      );
                      (t.innerHTML = r), h.prepend(t);
                    }
                    if (void 0 !== s) {
                      let e = h.querySelector("title");
                      if (
                        ((null == e ? void 0 : e.parentNode) &&
                          e.parentNode.removeChild(e),
                        s)
                      ) {
                        let e = document.createElementNS(
                          "http://www.w3.org/2000/svg",
                          "title"
                        );
                        (e.innerHTML = s), h.prepend(e);
                      }
                    }
                    return h;
                  } catch (e) {
                    return o(e);
                  }
                })({ ...e, handleError: R, hash: C.current, content: x }),
                n = c(t);
              if (!n || !(0, o.isValidElement)(n))
                throw Error("Could not convert the src to a React element");
              w({ element: n, status: f.READY });
            } catch (e) {
              R(Error(e.message));
            }
          }, [x, R, e]),
          M = (0, o.useCallback)(async () => {
            let e,
              n = /^data:image\/svg[^,]*?(;base64)?,(.*)/u.exec(h);
            if (
              (n
                ? (e = n[1] ? window.atob(n[2]) : decodeURIComponent(n[2]))
                : h.includes("<svg") && (e = h),
              e)
            )
              return void N(e);
            try {
              if (t) {
                let e = await r.get(h, a);
                N(e, !0);
              } else await T();
            } catch (e) {
              R(e);
            }
          }, [t, T, a, R, N, h]),
          P = (0, o.useCallback)(async () => {
            L.current &&
              w({
                content: "",
                element: null,
                isCached: !1,
                status: f.LOADING,
              });
          }, []);
        (0, o.useEffect)(() => {
          if (((L.current = !0), !g() || O.current)) return () => void 0;
          try {
            if (A === f.IDLE) {
              if (
                !(
                  (function () {
                    if (!document) return !1;
                    let e = document.createElement("div");
                    e.innerHTML = "<svg />";
                    let t = e.firstChild;
                    return (
                      !!t && "http://www.w3.org/2000/svg" === t.namespaceURI
                    );
                  })() &&
                  "undefined" != typeof window &&
                  null !== window
                )
              )
                throw Error("Browser does not support SVG");
              if (!h) throw Error("Missing src");
              P();
            }
          } catch (e) {
            R(e);
          }
          return (
            (O.current = !0),
            () => {
              L.current = !1;
            }
          );
        }, []),
          (0, o.useEffect)(() => {
            if (g() && S)
              if (S.src !== h) {
                if (!h) return void R(Error("Missing src"));
                P();
              } else (S.title !== p || S.description !== i) && I();
          }, [i, I, R, P, S, h, p]),
          (0, o.useEffect)(() => {
            D &&
              (D.status !== f.LOADING && A === f.LOADING && M(),
              D.status !== f.LOADED && A === f.LOADED && I(),
              D.status !== f.READY && A === f.READY && (null == d || d(h, E)));
          }, [M, I, E, d, D, h, A]);
        let z = (function (e) {
          for (
            var t = arguments.length, n = Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          let o = {};
          for (let t in e)
            ({}.hasOwnProperty.call(e, t) && !n.includes(t) && (o[t] = e[t]));
          return o;
        })(
          e,
          "baseURL",
          "cacheRequests",
          "children",
          "description",
          "fetchOptions",
          "innerRef",
          "loader",
          "onError",
          "onLoad",
          "preProcessor",
          "src",
          "title",
          "uniqueHash",
          "uniquifyIDs"
        );
        return g()
          ? b
            ? (0, o.cloneElement)(b, { ref: s, ...z })
            : [f.UNSUPPORTED, f.FAILED].includes(A)
            ? n
            : l
          : l;
      }
      function w(e) {
        r || (r = new y());
        let { loader: t } = e,
          n = (0, o.useRef)(!1),
          [i, a] = (0, o.useState)(r.isReady);
        return ((0, o.useEffect)(() => {
          n.current ||
            (r.onReady(() => {
              a(!0);
            }),
            (n.current = !0));
        }, []),
        i)
          ? (0, u.jsx)(k, { ...e })
          : t;
      }
    },
  },
]);
//# sourceMappingURL=1843-511addbacbc7fef4.js.map
